using System;
using System.IO;
using System.Text;
using System.Linq;
using System.IO.Ports;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;
using TMPro;

public class SettingsManager : MonoBehaviour
{
    // dictionary for iterating through values easier
    private Dictionary<string, InputField> _fields;
    private TMP_Dropdown _comPortsDropDown;
    private TMP_Dropdown _resolutionDropDown;

    // default values, static so that this doesn't get instantiated per object, not really necessary but saves memory
    private static Dictionary<string, object> _defaultValues = new Dictionary<string, object>()
    {
        ["Controller Frequency"] = 50, // this is the same frequency as the default physics update speed in unity
        ["Zeroing Time"] = 3, // how long it records the board to get the zero values
        ["Ramp Duration"] = 1.0f, // how long it takes to ramp up to 100% stimulation when the target changes
        ["Ankle Fraction"] = 2.0f, // percentage of total height that corresponds to the distance between heel to ankle
        ["Number of Trials"] = 2, // how many times the experiment will be run
        ["Arduino COM Port"] = "No COM Ports found", //how many arduinos and/or serival devices found
        ["Resolution"] = "1920x1080", //what resolution the game should use, games only work with 16:9 resolutions
        ["Filter Order"] = 2, // order of the moving average/butterworth filter
        ["Length Offset"] = 0.0f, // measure of how far the quiet standing centre of pressure is from the 0,0 of the board (ie. the centre)
        ["Star Multiplier"] = 120, // used for the unimplemented star game
        ["Root Path"] = Directory.GetCurrentDirectory(), // where any files generated by the program are stored
        ["Rolling Average Window"] = 1, // window used to calculate the average max excursion for los
        ["Height"] = 178, // height in cm
        ["Mass"] = 66f, //mass in kilos
        ["Duration of Target"] = 10, // how long each target lasts
        ["Duration to Get Points"] = 3, // how long the player needs to be in the target to get the points
        ["Assessment Duration"] = 100, // how long assessment lasts
        ["Game Duration"] = 100, // how long each game lasts
        ["RPF Max"] = 50f, // maximum stimulation for rpf
        ["RDF Max"] = 50f, // maximum stimulation for rdf
        ["LPF Max"] = 50f, // maximum stimulation for lpf
        ["LDF Max"] = 50f, // maximum stimulation for ldf
        ["RPF Motor Threshold"] = 0f, // RPF MT
        ["RDF Motor Threshold"] = 0f, // RDF MT
        ["LPF Motor Threshold"] = 0f, // LPF MT
        ["LDF Motor Threshold"] = 0f, // LDF MT
        ["Ankle Mass Fraction"] = 0.971f, // mass of body without feet
        ["CoM Height"] = 0.547f, // height of com relative to total height
        ["Inertia Coefficient"] = 0.319f, // coefficient to calculate the inertia
        ["Heel Position"] = 0.09f, // position of the heels in the ap direction relative to the centre of the board
        ["Kp Coefficient"] = 0.24432f, // coefficient of mgh_com to calculate Kp
        ["Kd Coefficient"] = 0.22418f, // coefficient of mgh_com to calculate Kd
        ["K Coefficient"] = 0.75024f, // coefficient of mgh_com to calculate K for mechnical controller
        ["Duration of Target"] = 10f, // how long the target lasts
        ["Duration to Get Points"] = 3f, // how long participants need to stay in the target to get the points
        ["Limit of Stability Front"] = 1f, // percentage of board, how far the participant can reach in the four directions, default needs to be one, if zero then it's a divide by zero error
        ["Limit of Stability Back"] = 1f, 
        ["Limit of Stability Left"] = 1f,
        ["Limit of Stability Right"] = 1f,
    };

    public static Dictionary<string, string> fieldNamesAndTypes = new Dictionary<string, string>() 
    {
        ["Controller Frequency"] = "int",
        ["Zeroing Time"] = "int",
        ["Ramp Duration"] = "float",
        ["Ankle Fraction"] = "float",
        ["Number of Trials"] = "int",
        ["Arduino COM Port"] = "string",
        ["Resolution"] = "string",
        ["Filter Order"] = "int",
        ["Length Offset"] = "float",
        ["Star Multiplier"] = "int",
        ["Root Path"] = "string",
        ["Rolling Average Window"] = "int",
        ["Height"] = "int",
        ["Mass"] = "float",
        ["Duration of Target"] = "int",
        ["Duration to Get Points"] = "int",
        ["Assessment Duration"] = "int",
        ["Game Duration"] = "int",
        ["RPF Max"] = "float",
        ["RDF Max"] = "float",
        ["LPF Max"] = "float",
        ["LDF Max"] = "float",
        ["RPF Motor Threshold"] = "float",
        ["RDF Motor Threshold"] = "float",
        ["LPF Motor Threshold"] = "float",
        ["LDF Motor Threshold"] = "float",
        ["Ankle Mass Fraction"] = "float",
        ["CoM Height"] = "float",
        ["Inertia Coefficient"] = "float",
        ["Heel Position"] = "float",
        ["Kp Coefficient"] = "float",
        ["Kd Coefficient"] = "float",
        ["K Coefficient"] = "float",
        ["Duration of Target"] = "float",
        ["Duration to Get Points"] = "float",
        ["Limit of Stability Front"] = "float",
        ["Limit of Stability Back"] = "float",
        ["Limit of Stability Left"] = "float",
        ["Limit of Stability Right"] = "float"
    };

    private void Start()
    {
        if (SceneManager.GetActiveScene().buildIndex == 0) //only do this at the start screen
        {
            foreach (var nameAndType in fieldNamesAndTypes)
            {
                if (!PlayerPrefs.HasKey(nameAndType.Key)) //if opening up game for first time, set all values to default, missing values also set to default
                {
                    if (nameAndType.Value == "int")
                        PlayerPrefs.SetInt(nameAndType.Key, (int)_defaultValues[nameAndType.Key]);
                    else if (nameAndType.Value == "float")
                        PlayerPrefs.SetFloat(nameAndType.Key, (float)_defaultValues[nameAndType.Key]);
                    else
                        PlayerPrefs.SetString(nameAndType.Key, (string)_defaultValues[nameAndType.Key]);
                }
            }
        }
        else if (SceneManager.GetActiveScene().buildIndex == 1) //buildIndex 1 should be settings
        {
            _fields = new Dictionary<string, InputField>();

            SetInputFields();
        }
    }

    private void SetInputFields() //this is called by sceneloader when the settings page is loaded
    {
        var fields = FindObjectsOfType<InputField>();
        var dropDowns = FindObjectsOfType<TMP_Dropdown>().ToList(); //find all drop downs
        _comPortsDropDown = dropDowns.Find(value => value.name == "Arduino COM Port");
        _resolutionDropDown = dropDowns.Find(value => value.name == "Resolution");

        //array form, want to convert to dictionary instead - easier to work with
        foreach (var field in fields)
            _fields[field.name] = field;

        SetInputs();
    }

    public void SaveSettings()
    {
        foreach (var nameAndType in fieldNamesAndTypes) //saves new set values
        {
            if (nameAndType.Key == "Arduino COM Port")
            {
                //check if a com port was even found, if not skip saving any values
                if (_comPortsDropDown.options[_comPortsDropDown.value].text == (string)_defaultValues[nameAndType.Key])
                    continue;

                //check if the com port selected is even an arduino device, if not don't save and output a message
                if (!CheckIfArduino())
                    continue;

                //finally if all above conditions are good, we can save the com port
                PlayerPrefs.SetString(nameAndType.Key, _comPortsDropDown.options[_comPortsDropDown.value].text);

                continue;
            }
            if (nameAndType.Key == "Resolution")
            {
                //saving resolution
                PlayerPrefs.SetString(nameAndType.Key, _resolutionDropDown.options[_resolutionDropDown.value].text);

                //setting resolution when we press save
                var dim = Array.ConvertAll(_resolutionDropDown.options[_resolutionDropDown.value].text.Split('x'), s => Convert.ToInt32(s)); // wxh

                Screen.SetResolution(dim[0], dim[1], Convert.ToBoolean(PlayerPrefs.GetInt("Fullscreen")));
                continue;
            }

            if (nameAndType.Value == "int")
                PlayerPrefs.SetInt(nameAndType.Key, Convert.ToInt32(_fields[nameAndType.Key].text));
            else if (nameAndType.Value == "float")
                PlayerPrefs.SetFloat(nameAndType.Key, float.Parse(_fields[nameAndType.Key].text));
            else 
            {
                if (Directory.Exists(_fields[nameAndType.Key].text))
                    PlayerPrefs.SetString(nameAndType.Key, _fields[nameAndType.Key].text);
                else
                    _fields["Info"].text += "Root path doesn't exist. Please provide a valid path\n";
            }
        }

        PlayerPrefs.Save();
        Time.fixedDeltaTime = 1f/PlayerPrefs.GetInt("Controller Frequency", 50); //set physics loop speed to the speed set in the settings
    }

    private bool CheckIfArduino()
    {
        var serialPort = new SerialPort(_comPortsDropDown.options[_comPortsDropDown.value].text, 115200);

        try
        {
            serialPort.ReadTimeout = 200;
            serialPort.Open();
            serialPort.Write("s64"); //unique string to send to arduino, if the device returns 64, then it's an arduino
            serialPort.BaseStream.Flush();
            
            var buffer = new byte[5];
            var bufferUsed = 0;
            var separator = 44; //ascii code for comma, which is our separator, will need to be manually changed if separator changes

            // Try to fill the internal buffer, have to do this twice because it sometimes doesn't read the whole thing for some reason
            bufferUsed += serialPort.Read(buffer, bufferUsed, buffer.Length - bufferUsed);
            bufferUsed += serialPort.Read(buffer, bufferUsed, buffer.Length - bufferUsed);

            // Search for the separator in the buffer
            var index = Array.FindIndex<byte>(buffer, 0, bufferUsed, item => item == separator);

            if (index == -1) //if -1 is returned, that means separator wasn't found and we should return false
            {
                serialPort.Close(); //we have to close the port once we're done, otherwise it might cause problems later
                return false;
            }  
            
            var returnBuffer = new byte[index];
            Array.Copy(buffer, returnBuffer, index);
            var returnString = Encoding.ASCII.GetString(returnBuffer); //convert byte[] to string with ascii encoding

            if (returnString == "64")
            {
                serialPort.Close();
                return true;
            }
                
            serialPort.Close();
            return false;
        }
        catch (TimeoutException)
        {
            _fields["Info"].text += "Connection timed out. Check that you selected the right port and that the Arduino is " +
                                    "connected properly to the computer\n";
            serialPort.Close();
            return false;
        }
    }

    public void ResetToDefaults()
    {
        PlayerPrefs.DeleteAll();
        SetInputs();
    }

    //toggles are saved separately
    public void FullScreen() => CheckBoxDelegate("Fullscreen");

    public void FilterData() => CheckBoxDelegate("Filter Data");

    public void ECOrEO() => CheckBoxDelegate("Eyes Condition");

    public void ReadArduino() => CheckBoxDelegate("Read From Arduino");

    private void SetInputs()
    {
        foreach (var nameAndType in fieldNamesAndTypes)
        {
            if (nameAndType.Key == "Arduino COM Port")
            {
                var ports = SerialPort.GetPortNames().ToList(); //get all serial device names

                if (ports.Count ==  0) //give default message in dropdown if no arduino was found
                {
                    if (_comPortsDropDown.options.Count != 0)
                        _comPortsDropDown.ClearOptions();
                    _comPortsDropDown.AddOptions(new List<string>() {(string)_defaultValues[nameAndType.Key]});
                    continue;
                }
                else //if serial device or arduino exists, put the com port name in dropdown
                {
                    if (_comPortsDropDown.options.Count != 0)
                        _comPortsDropDown.ClearOptions();
                    _comPortsDropDown.AddOptions(ports);
                }

                var storedValue = PlayerPrefs.GetString(nameAndType.Key, "");

                //if COM port has not been saved, just pick the first value in the list by default
                if (String.IsNullOrEmpty(storedValue))
                    _comPortsDropDown.value = 0;
                else
                {
                    try //try to find the stored com port in list and set it to that, if it isn't there, just it to the first item
                    {
                        var index = _comPortsDropDown.options.FindIndex(0, option => option.text == storedValue);
                        _comPortsDropDown.value = index;
                    }
                    catch (Exception exception)
                    {
                        _comPortsDropDown.value = 0;
                        Debug.Log("Setting dropdown to first option by default " + exception.Message);
                    }
                }

                continue; //skip the rest of the code below and go onto the next iteration
            }
            else if (nameAndType.Key == "Resolution")
            {
                if (_resolutionDropDown.options.Count != 0) //just in case options isn't empty for some reason
                    _resolutionDropDown.ClearOptions();

                string currentRes;
                //restrict the user to only selecting 16:9 resolutions, if there's nothing there, then 16:9 resolutions weren't found
                var resolutions = Screen.resolutions.ToList().FindAll(res => Mathf.Approximately(Convert.ToSingle(res.width)/Convert.ToSingle(res.height), 16f/9f)); //only list 16:9 resolutions
                var resolutionsText = new List<string>(resolutions.Select(res => res.width.ToString() + "x" + res.height.ToString()).Reverse());
                _resolutionDropDown.AddOptions(resolutionsText);

                if (!PlayerPrefs.HasKey(nameAndType.Key)) //if this has never been saved before, use the current resolution
                    currentRes = Screen.currentResolution.width + "x" + Screen.currentResolution.height;
                else
                    currentRes = PlayerPrefs.GetString(nameAndType.Key, "");

                //set current monitor resolution
                _resolutionDropDown.value = _resolutionDropDown.options.FindIndex(0, res => res.text == currentRes);

                continue;
            }

            if (nameAndType.Value == "int") //try to get the value stored on computer, if it doens't exist, use default values
                _fields[nameAndType.Key].text = PlayerPrefs.GetInt(nameAndType.Key, (int)_defaultValues[nameAndType.Key]).ToString();
            else if (nameAndType.Value == "float")
                _fields[nameAndType.Key].text = PlayerPrefs.GetFloat(nameAndType.Key, (float)_defaultValues[nameAndType.Key]).ToString();
            else
                _fields[nameAndType.Key].text = PlayerPrefs.GetString(nameAndType.Key, (string)_defaultValues[nameAndType.Key]);
        }

        var toggles = FindObjectsOfType<Toggle>();

        foreach (var toggle in toggles) //set toggle setting
        {
            var toggleName = toggle.name;
            var defaultValue = 0;
            
            if (toggleName == "Eyes Condition" || toggleName == "Fullscreen") //default fullscreen and eo for qs assessment
                defaultValue = 1;
            
            toggle.GetComponent<Toggle>().isOn = Convert.ToBoolean(PlayerPrefs.GetInt(toggleName, defaultValue));
        }
    }

    private void CheckBoxDelegate(string checkBoxName)
    {
        var isChecked = GameObject.Find(checkBoxName).GetComponent<Toggle>().isOn;

        if (isChecked)
            PlayerPrefs.SetInt(checkBoxName, 1);
        else
            PlayerPrefs.SetInt(checkBoxName, 0);
    }
}